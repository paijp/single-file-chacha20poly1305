
#include	"c20p1305.h"
#include	<stdio.h>


static	void	poly1305_auth(UB mac[16], const UB *m, W bytes, const UB key[32])
{
	struct	poly1305_state_internal_struct	state;
	
	poly1305_init(&state, key);
	poly1305_update(&state, m, bytes);
	poly1305_finish(&state, mac);
}


static	int	poly1305_verify(const UB mac1[16], const UB mac2[16])
{
	W	i;
	UH	dif;
	
	dif = 0;
	for (i=0; i<16; i++)
		dif |= (mac1[i] ^ mac2[i]);
	return ((dif - 1) >> (sizeof(dif) * 8 - 1)) & 1;
}


/* test a few basic operations */
int
poly1305_power_on_self_test(void) {
	/* example from nacl */
	static const UB nacl_key[32] = {
		0xee,0xa6,0xa7,0x25,0x1c,0x1e,0x72,0x91,
		0x6d,0x11,0xc2,0xcb,0x21,0x4d,0x3c,0x25,
		0x25,0x39,0x12,0x1d,0x8e,0x23,0x4e,0x65,
		0x2d,0x65,0x1f,0xa4,0xc8,0xcf,0xf8,0x80
	};

	static const UB nacl_msg[131] = {
		0x8e,0x99,0x3b,0x9f,0x48,0x68,0x12,0x73,
		0xc2,0x96,0x50,0xba,0x32,0xfc,0x76,0xce,
		0x48,0x33,0x2e,0xa7,0x16,0x4d,0x96,0xa4,
		0x47,0x6f,0xb8,0xc5,0x31,0xa1,0x18,0x6a,
		0xc0,0xdf,0xc1,0x7c,0x98,0xdc,0xe8,0x7b,
		0x4d,0xa7,0xf0,0x11,0xec,0x48,0xc9,0x72,
		0x71,0xd2,0xc2,0x0f,0x9b,0x92,0x8f,0xe2,
		0x27,0x0d,0x6f,0xb8,0x63,0xd5,0x17,0x38,
		0xb4,0x8e,0xee,0xe3,0x14,0xa7,0xcc,0x8a,
		0xb9,0x32,0x16,0x45,0x48,0xe5,0x26,0xae,
		0x90,0x22,0x43,0x68,0x51,0x7a,0xcf,0xea,
		0xbd,0x6b,0xb3,0x73,0x2b,0xc0,0xe9,0xda,
		0x99,0x83,0x2b,0x61,0xca,0x01,0xb6,0xde,
		0x56,0x24,0x4a,0x9e,0x88,0xd5,0xf9,0xb3,
		0x79,0x73,0xf6,0x22,0xa4,0x3d,0x14,0xa6,
		0x59,0x9b,0x1f,0x65,0x4c,0xb4,0x5a,0x74,
		0xe3,0x55,0xa5
	};

	static const UB nacl_mac[16] = {
		0xf3,0xff,0xc7,0x70,0x3f,0x94,0x00,0xe5,
		0x2a,0x7d,0xfb,0x4b,0x3d,0x33,0x05,0xd9
	};

	/* generates a final value of (2^130 - 2) == 3 */
	static const UB wrap_key[32] = {
		0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	};

	static const UB wrap_msg[16] = {
		0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
		0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
	};

	static const UB wrap_mac[16] = {
		0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	};

	/*
		mac of the macs of messages of length 0 to 256, where the key and messages
		have all their values set to the length
	*/
	static const UB total_key[32] = {
		0x01,0x02,0x03,0x04,0x05,0x06,0x07,
		0xff,0xfe,0xfd,0xfc,0xfb,0xfa,0xf9,
		0xff,0xff,0xff,0xff,0xff,0xff,0xff,
		0xff,0xff,0xff,0xff,0xff,0xff,0xff, 0, 0, 0, 0
	};

	static const UB total_mac[16] = {
		0x64,0xaf,0xe2,0xe8,0xd6,0xad,0x7b,0xbd,
		0xd2,0x87,0xf9,0x7c,0x44,0x62,0x3d,0x39
	};

	struct	poly1305_state_internal_struct state;
	struct	poly1305_state_internal_struct total_state;
	UB	all_key[32];
	UB	all_msg[256];
	UB	mac[16];
	W	i, j;
	
	for (i = 0; i < sizeof(mac); i++)
		mac[i] = 0;
	poly1305_auth(mac, nacl_msg, sizeof(nacl_msg), nacl_key);
	printf("poly1305_verify(%d)\n", poly1305_verify(nacl_mac, mac));

	for (i = 0; i < sizeof(mac); i++)
		mac[i] = 0;
	poly1305_init(&state, nacl_key);
	poly1305_update(&state, nacl_msg +   0, 32);
	poly1305_update(&state, nacl_msg +  32, 64);
	poly1305_update(&state, nacl_msg +  96, 16);
	poly1305_update(&state, nacl_msg + 112,  8);
	poly1305_update(&state, nacl_msg + 120,  4);
	poly1305_update(&state, nacl_msg + 124,  2);
	poly1305_update(&state, nacl_msg + 126,  1);
	poly1305_update(&state, nacl_msg + 127,  1);
	poly1305_update(&state, nacl_msg + 128,  1);
	poly1305_update(&state, nacl_msg + 129,  1);
	poly1305_update(&state, nacl_msg + 130,  1);
	poly1305_finish(&state, mac);
	printf("poly1305_verify(%d)\n", poly1305_verify(nacl_mac, mac));

	for (i = 0; i < sizeof(mac); i++)
		mac[i] = 0;
	poly1305_auth(mac, wrap_msg, sizeof(wrap_msg), wrap_key);
	printf("poly1305_verify(%d)\n", poly1305_verify(wrap_mac, mac));

	poly1305_init(&total_state, total_key);
	for (i = 0; i < 256; i++) {
		/* set key and message to 'i,i,i..' */
		for (j = 0; j < sizeof(all_key); j++)
			all_key[j] = i;
		for (j = 0; j < i; j++)
			all_msg[j] = i;
		poly1305_auth(mac, all_msg, i, all_key);
		poly1305_update(&total_state, mac, 16);
	}
	poly1305_finish(&total_state, mac);
	printf("poly1305_verify(%d)\n", poly1305_verify(total_mac, mac));
	
	return 1;
}


static	int	c20p1305test()
{
/* from https://github.com/wg/c20p1305 */
	static	const	UB	plaintext[] = {
		0x4c, 0x61, 0x64, 0x69, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x47, 0x65, 0x6e, 0x74, 0x6c,
		0x65, 0x6d, 0x65, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x61, 0x73,
		0x73, 0x20, 0x6f, 0x66, 0x20, 0x27, 0x39, 0x39, 0x3a, 0x20, 0x49, 0x66, 0x20, 0x49, 0x20, 0x63,
		0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6f,
		0x6e, 0x6c, 0x79, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x74, 0x69, 0x70, 0x20, 0x66, 0x6f, 0x72, 0x20,
		0x74, 0x68, 0x65, 0x20, 0x66, 0x75, 0x74, 0x75, 0x72, 0x65, 0x2c, 0x20, 0x73, 0x75, 0x6e, 0x73,
		0x63, 0x72, 0x65, 0x65, 0x6e, 0x20, 0x77, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x69,
		0x74, 0x2e
	};
	static	const	UB	aad[] = {
		0x50, 0x51, 0x52, 0x53, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7
	};
	static	const	UB	key[] = {
		0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
		0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f
	};
	static	const	UB	nonce[] = {
		0x07, 0x00, 0x00, 0x00,
		0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47
	};
	static	const	UB	ciphertext[] = {
		0xd3, 0x1a, 0x8d, 0x34, 0x64, 0x8e, 0x60, 0xdb, 0x7b, 0x86, 0xaf, 0xbc, 0x53, 0xef, 0x7e, 0xc2,
		0xa4, 0xad, 0xed, 0x51, 0x29, 0x6e, 0x08, 0xfe, 0xa9, 0xe2, 0xb5, 0xa7, 0x36, 0xee, 0x62, 0xd6,
		0x3d, 0xbe, 0xa4, 0x5e, 0x8c, 0xa9, 0x67, 0x12, 0x82, 0xfa, 0xfb, 0x69, 0xda, 0x92, 0x72, 0x8b,
		0x1a, 0x71, 0xde, 0x0a, 0x9e, 0x06, 0x0b, 0x29, 0x05, 0xd6, 0xa5, 0xb6, 0x7e, 0xcd, 0x3b, 0x36,
		0x92, 0xdd, 0xbd, 0x7f, 0x2d, 0x77, 0x8b, 0x8c, 0x98, 0x03, 0xae, 0xe3, 0x28, 0x09, 0x1b, 0x58,
		0xfa, 0xb3, 0x24, 0xe4, 0xfa, 0xd6, 0x75, 0x94, 0x55, 0x85, 0x80, 0x8b, 0x48, 0x31, 0xd7, 0xbc,
		0x3f, 0xf4, 0xde, 0xf0, 0x8e, 0x4b, 0x7a, 0x9d, 0xe5, 0x76, 0xd2, 0x65, 0x86, 0xce, 0xc6, 0x4b,
		0x61, 0x16
	};
	static	const	UB	tag[] = {
		0x1a, 0xe1, 0x0b, 0x59, 0x4f, 0x09, 0xe2, 0x6a, 0x7e, 0x90, 0x2e, 0xcb, 0xd0, 0x60, 0x06, 0x91
	};
	
	{
		static	UB	mac[16];
		static	UB	work[sizeof(plaintext)];
		W	i;
		
		for (i=0; i<sizeof(work); i++)
			work[i] = plaintext[i];
		c20p1305_xor(work, sizeof(work), key, nonce);
		for (i=0; i<sizeof(work); i++)
			if (work[i] != ciphertext[i]) {
				printf("work[%d]:%02x ciphertext[%d]:%02x\n", i, work[i], i, ciphertext[i]);
				return 1;
			}
		printf("encrypt ok.\n");
		
		c20p1305_mac(mac, aad, sizeof(aad), work, sizeof(work), key, nonce);
		for (i=0; i<sizeof(mac); i++)
			if (mac[i] != tag[i]) {
				printf("mac[%d]:%02x tag[%d]:%02x\n", i, mac[i], i, tag[i]);
				return 1;
			}
		printf("mac ok.\n");
	}
	return 0;
}


int
main(void) {
	const unsigned char expected[16] = {0xdd,0xb9,0xda,0x7d,0xdd,0x5e,0x52,0x79,0x27,0x30,0xed,0x5c,0xda,0x5f,0x90,0xa4};
	unsigned char key[32];
	unsigned char mac[16];
	unsigned char msg[73];
	size_t i;
	int success = poly1305_power_on_self_test();

	printf("poly1305 self test: %s\n", success ? "successful" : "failed");
	if (!success)
		return 1;

	for (i = 0; i < sizeof(key); i++)
		key[i] = (unsigned char)(i + 221);
	for (i = 0; i < sizeof(msg); i++)
		msg[i] = (unsigned char)(i + 121);
	poly1305_auth(mac, msg, sizeof(msg), key);

	printf("sample mac is ");
	for (i = 0; i < sizeof(mac); i++)
		printf("%02x", mac[i]);
	printf(" (%s)\n", poly1305_verify(expected, mac) ? "correct" : "incorrect");

	return c20p1305test();
}

